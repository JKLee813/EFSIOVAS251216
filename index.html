<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Screen Number Tracker</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #0f0;
    font-family: monospace;
    text-align: center;
  }

  #container {
    position: relative;
    display: inline-block;
    margin-top: 10px;
  }

  canvas {
    display: block;
  }

  #capture {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  #overlay {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    pointer-events: auto;
    cursor: crosshair;
  }

  #result {
    font-size: 32px;
    margin-top: 10px;
  }

  button {
    font-size: 16px;
    padding: 8px 16px;
    margin-top: 10px;
  }
</style>
</head>
<body>

<h2>Screen Number Tracker</h2>
<button id="start">화면 공유 시작</button>
<div id="result">---</div>

<div id="container">
  <canvas id="capture"></canvas>
  <canvas id="overlay"></canvas>
</div>

<video id="video" autoplay playsinline hidden></video>

<script>
const video = document.getElementById("video");
const cap = document.getElementById("capture");
const ov = document.getElementById("overlay");
const capCtx = cap.getContext("2d");
const ovCtx = ov.getContext("2d");
const resultDiv = document.getElementById("result");

let roi = null;
let selecting = false;
let sx = 0, sy = 0;

document.getElementById("start").onclick = async () => {
  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: { frameRate: 30 }
  });
  video.srcObject = stream;

  video.onloadedmetadata = () => {
    const w = video.videoWidth;
    const h = video.videoHeight;

    cap.width = ov.width = w;
    cap.height = ov.height = h;

    cap.style.width = ov.style.width = w + "px";
    cap.style.height = ov.style.height = h + "px";

    requestAnimationFrame(loop);
  };
};

/* ===== ROI Drag ===== */

ov.addEventListener("mousedown", e => {
  selecting = true;
  sx = e.offsetX;
  sy = e.offsetY;
});

ov.addEventListener("mousemove", e => {
  if (!selecting) return;

  const x = e.offsetX;
  const y = e.offsetY;

  roi = {
    x: Math.min(sx, x),
    y: Math.min(sy, y),
    w: Math.abs(x - sx),
    h: Math.abs(y - sy)
  };

  ovCtx.clearRect(0, 0, ov.width, ov.height);
  ovCtx.strokeStyle = "lime";
  ovCtx.lineWidth = 2;
  ovCtx.strokeRect(roi.x, roi.y, roi.w, roi.h);
});

ov.addEventListener("mouseup", () => selecting = false);
ov.addEventListener("mouseleave", () => selecting = false);

/* ===== Main Loop ===== */

function loop() {
  capCtx.drawImage(video, 0, 0);

  if (roi && roi.w > 10 && roi.h > 10) {
    const img = capCtx.getImageData(
      roi.x, roi.y, roi.w, roi.h
    );
    const val = readNumber(img);
    resultDiv.textContent = val ?? "---";
  }

  requestAnimationFrame(loop);
}

/* ===== OCR ===== */

function readNumber(img) {
  const g = toGray(img);
  const digits = splitDigits(g, img.width, img.height);
  if (!digits.length) return null;

  let out = "";
  for (const [l, r] of digits) {
    let bits = 0;
    for (let x = l; x < r; x++) {
      for (let y = 0; y < img.height; y++) {
        if (g[y*img.width + x] < 140) {
          bits |= 1 << Math.floor((y / img.height) * 7);
        }
      }
    }
    out += matchDigit(bits);
  }
  return out;
}

function toGray(img) {
  const g = [];
  for (let i = 0; i < img.data.length; i += 4) {
    g.push(
      img.data[i]*0.3 +
      img.data[i+1]*0.59 +
      img.data[i+2]*0.11
    );
  }
  return g;
}

function splitDigits(gray, w, h) {
  const cols = [];
  for (let x = 0; x < w; x++) {
    let s = 0;
    for (let y = 0; y < h; y++) {
      s += gray[y*w + x];
    }
    cols.push(s / h);
  }

  const res = [];
  let start = null;
  for (let i = 0; i < cols.length; i++) {
    if (cols[i] < 200 && start === null) start = i;
    if (cols[i] >= 200 && start !== null) {
      if (i - start > 2) res.push([start, i]);
      start = null;
    }
  }
  return res;
}

const DIGITS = {
  0: 0b1110111,
  1: 0b0100100,
  2: 0b1011101,
  3: 0b1101101,
  4: 0b0101110,
  5: 0b1101011,
  6: 0b1111011,
  7: 0b0100101,
  8: 0b1111111,
  9: 0b1101111,
};

function matchDigit(bits) {
  let best = "?";
  let err = 999;
  for (const k in DIGITS) {
    const e = bitCount(bits ^ DIGITS[k]);
    if (e < err) {
      err = e;
      best = k;
    }
  }
  return best;
}

function bitCount(n) {
  let c = 0;
  while (n) {
    n &= n - 1;
    c++;
  }
  return c;
}
</script>
</body>
</html>
