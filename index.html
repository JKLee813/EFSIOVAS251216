<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Improved Contrast-based Number OCR</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #0f0;
    font-family: monospace;
    text-align: center;
  }
  #container {
    position: relative;
    display: inline-block;
    margin-top: 10px;
  }
  canvas { display: block; }
  #capture {
    position: absolute;
    top: 0; left: 0;
    z-index: 1;
  }
  #overlay {
    position: absolute;
    top: 0; left: 0;
    z-index: 2;
    pointer-events: auto;
    cursor: crosshair;
  }
  #result {
    font-size: 32px;
    margin-top: 10px;
  }
  button {
    font-size: 16px;
    padding: 8px 16px;
    margin-top: 10px;
  }
</style>
</head>
<body>

<h2>Contrast-based Screen Number OCR</h2>
<button id="start">화면 공유 시작 (개선 v2.0)</button>
<div id="result">---</div>

<div id="container">
  <canvas id="capture"></canvas>
  <canvas id="overlay"></canvas>
</div>

<video id="video" autoplay playsinline hidden></video>

<script>
/* ================== Setup ================== */
const video = document.getElementById("video");
const cap = document.getElementById("capture");
const ov = document.getElementById("overlay");
const capCtx = cap.getContext("2d");
const ovCtx = ov.getContext("2d");
const resultDiv = document.getElementById("result");

let roi = null;
let selecting = false;
let sx = 0, sy = 0;

/* ================== Screen Share ================== */
document.getElementById("start").onclick = async () => {
  const stream = await navigator.mediaDevices.getDisplayMedia({
    video: { frameRate: 30 }
  });
  video.srcObject = stream;

  video.onloadedmetadata = () => {
    const w = video.videoWidth;
    const h = video.videoHeight;

    cap.width = ov.width = w;
    cap.height = ov.height = h;

    cap.style.width = ov.style.width = w + "px";
    cap.style.height = ov.style.height = h + "px";

    requestAnimationFrame(loop);
  };
};

/* ================== ROI Drag ================== */
ov.addEventListener("mousedown", e => {
  selecting = true;
  sx = e.offsetX;
  sy = e.offsetY;
});

ov.addEventListener("mousemove", e => {
  if (!selecting) return;

  const x = e.offsetX;
  const y = e.offsetY;

  roi = {
    x: Math.min(sx, x),
    y: Math.min(sy, y),
    w: Math.abs(x - sx),
    h: Math.abs(y - sy)
  };

  ovCtx.clearRect(0,0,ov.width,ov.height);
  ovCtx.strokeStyle = "lime";
  ovCtx.lineWidth = 2;
  ovCtx.strokeRect(roi.x, roi.y, roi.w, roi.h);
});

ov.addEventListener("mouseup", () => selecting = false);
ov.addEventListener("mouseleave", () => selecting = false);

/* ================== Main Loop ================== */
function loop() {
  capCtx.drawImage(video, 0, 0);

  if (roi && roi.w > 10 && roi.h > 10) {
    const img = capCtx.getImageData(roi.x, roi.y, roi.w, roi.h);
    const value = stableValue(readNumber(img));
    resultDiv.textContent = value || "---";
  }
  requestAnimationFrame(loop);
}

/* ================== OCR Core (IMPROVED) ================== */

function readNumber(img) {
  const gray = toGray(img);
  const bin = otsuBinarize(gray, img.width, img.height); // Pass width/height
  const clean = denoise(bin, img.width, img.height);
  const digits = splitDigits(clean, img.width, img.height);

  if (!digits.length) return null;

  let out = "";
  for (const [l, r] of digits) {
    const digitW = r - l;
    const digitH = img.height;
    const digitImg = new Uint8Array(digitW * digitH);
    for (let y = 0; y < digitH; y++) {
      for (let x = 0; x < digitW; x++) {
        digitImg[y * digitW + x] = clean[y * img.width + (l + x)];
      }
    }
    
    out += matchTemplate(digitImg, digitW, digitH);
  }
  return out;
}

/* ---- grayscale (unchanged) ---- */
function toGray(img) {
  const g = new Uint8Array(img.width * img.height);
  for (let i = 0, j = 0; i < img.data.length; i += 4, j++) {
    g[j] =
      img.data[i] * 0.3 +
      img.data[i+1] * 0.59 +
      img.data[i+2] * 0.11;
  }
  return g;
}

/* ---- NEW: Otsu's Binarization with Auto-Invert ---- */
function otsuBinarize(gray, w, h) {
    const hist = new Int32Array(256).fill(0);
    for (let i = 0; i < gray.length; i++) {
        hist[gray[i]]++;
    }

    const total = gray.length;
    let sum = 0;
    for (let t = 0; t < 256; t++) sum += t * hist[t];

    let sumB = 0;
    let wB = 0;
    let wF = 0;
    let mB, mF;
    let max = 0;
    let between = 0;
    let threshold = 0;
    let finalMB = 0;
    let finalMF = 0;

    for (let t = 0; t < 256; t++) {
        wB += hist[t];
        if (wB === 0) continue;
        wF = total - wB;
        if (wF === 0) break;
        sumB += t * hist[t];
        mB = sumB / wB;
        mF = (sum - sumB) / wF;
        between = wB * wF * (mB - mF) * (mB - mF);
        if (between > max) {
            max = between;
            threshold = t;
            finalMB = mB;
            finalMF = mF;
        }
    }

    const bin = new Uint8Array(gray.length);
    // If mean of foreground is greater than mean of background,
    // it's likely light text on a dark background.
    const lightOnDark = finalMF > finalMB;

    for (let i = 0; i < gray.length; i++) {
        if (lightOnDark) {
            bin[i] = gray[i] > threshold ? 1 : 0;
        } else {
            bin[i] = gray[i] <= threshold ? 1 : 0;
        }
    }
    return bin;
}

/* ---- IMPROVED: denoise (3x3 true majority) ---- */
function denoise(bin, w, h) {
  const out = new Uint8Array(bin.length);
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      let c = 0;
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -1; dx <= 1; dx++)
          c += bin[(y + dy) * w + (x + dx)];
      out[y * w + x] = c >= 5 ? 1 : 0;
    }
  }
  return out;
}

/* ---- IMPROVED: vertical projection split ---- */
function splitDigits(bin, w, h) {
  const proj = new Int32Array(w).fill(0);
  for (let x = 0; x < w; x++) {
    for (let y = 0; y < h; y++) {
      proj[x] += bin[y * w + x];
    }
  }

  const res = [];
  let inDigit = false;
  let start = 0;
  for (let x = 0; x < w; x++) {
    const hasPixels = proj[x] > 1; 
    if (hasPixels && !inDigit) {
      start = x;
      inDigit = true;
    } else if (!hasPixels && inDigit) {
      if (x - start > 3) {
        res.push([start, x]);
      }
      inDigit = false;
    }
  }
  if (inDigit && w - start > 3) {
    res.push([start, w]);
  }
  return res;
}

/* ================== NEW: Template Matching Engine ================== */
const TEMPLATES = {
  '0': "01111111011000011110000111100001111000011110011011110011011110011011110000111100001111000011011111110",
  '1': "000110000001110000001011000000001100000000110000000011000000001100000000110000000011000000001100000011111111",
  '2': "01111110110000111000001100000011000001100001100011001100110011001100011111111111111111",
  '3': "0111111011000011000000110000011001111100000011000000111100001111000011011111110",
  '4': "0000110000001110000011110000110110001100110011111111110000110000000011000000001100000000110000",
  '5': "1111111111100000001100000001111111010000001100000011000001111000011111111110",
  '6': "0011111001100000011000000011111110110000111100001111000011011111110",
  '7': "1111111111000001110000011000001100001100001100001100001100000110000011000",
  '8': "01111110110000111100001101111110110000111100001111000011011111110",
  '9': "011111101100001111000011011111111000000110000011000011000110001111100",
};

const TEMPLATE_W = 10;
const TEMPLATE_H = 15;
const BINARY_TEMPLATES = {};
for (const key in TEMPLATES) {
  BINARY_TEMPLATES[key] = TEMPLATES[key].split('').map(Number);
}

function resize(digit, w, h, out_w, out_h) {
  const out = new Uint8Array(out_w * out_h);
  const x_ratio = w / out_w;
  const y_ratio = h / out_h;
  for (let y = 0; y < out_h; y++) {
    for (let x = 0; x < out_w; x++) {
      const px = Math.floor(x * x_ratio);
      const py = Math.floor(y * y_ratio);
      out[y * out_w + x] = digit[py * w + px];
    }
  }
  return out;
}

function matchTemplate(digitImg, w, h) {
  if (w < 1 || h < 1) return "";
  
  const normalized = resize(digitImg, w, h, TEMPLATE_W, TEMPLATE_H);
  
  let bestMatch = "";
  let minDiff = Infinity;

  for (const num in BINARY_TEMPLATES) {
    const template = BINARY_TEMPLATES[num];
    let diff = 0;
    for (let i = 0; i < normalized.length; i++) {
      if (normalized[i] !== template[i]) {
        diff++;
      }
    }
    if (diff < minDiff) {
      minDiff = diff;
      bestMatch = num;
    }
  }
  
  if (minDiff > 52) { // Confidence threshold (approx 35% error)
      return "";
  }

  return bestMatch;
}

/* ================== Frame Stabilizer (unchanged) ================== */
const history = [];
const MAX_H = 5;

function stableValue(v) {
  if (v === null || v === undefined) return v;
  history.push(v);
  if (history.length > MAX_H) history.shift();

  const map = {};
  for (const x of history) map[x] = (map[x] || 0) + 1;
  return Object.entries(map).sort((a,b)=>b[1]-a[1])[0][0];
}
</script>
</body>
</html>
