<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Robust Screen OCR</title>
<style>
body {
  background:#111; color:#0f0; font-family:monospace; text-align:center;
}
#container { position:relative; display:inline-block; }
canvas { display:block; }
#capture { position:absolute; z-index:1; }
#overlay { position:absolute; z-index:2; cursor:crosshair; }
#result { font-size:32px; margin-top:10px; }
</style>
</head>
<body>

<h2>Robust Contrast OCR</h2>
<button id="start">화면 공유 시작v0.3</button>
<div id="result">---</div>

<div id="container">
  <canvas id="capture"></canvas>
  <canvas id="overlay"></canvas>
</div>

<video id="video" autoplay hidden></video>

<script>
const video = document.getElementById("video");
const cap = document.getElementById("capture");
const ov = document.getElementById("overlay");
const capCtx = cap.getContext("2d");
const ovCtx = ov.getContext("2d");
const resultDiv = document.getElementById("result");

let roi=null, selecting=false, sx=0, sy=0;

/* ===== Screen Share ===== */
document.getElementById("start").onclick = async () => {
  const s = await navigator.mediaDevices.getDisplayMedia({video:true});
  video.srcObject = s;
  video.onloadedmetadata = () => {
    cap.width = ov.width = video.videoWidth;
    cap.height = ov.height = video.videoHeight;
    requestAnimationFrame(loop);
  };
};

/* ===== ROI ===== */
ov.onmousedown = e => { selecting=true; sx=e.offsetX; sy=e.offsetY; };
ov.onmousemove = e => {
  if(!selecting) return;
  const x=e.offsetX, y=e.offsetY;
  roi={x:Math.min(sx,x),y:Math.min(sy,y),w:Math.abs(x-sx),h:Math.abs(y-sy)};
  ovCtx.clearRect(0,0,ov.width,ov.height);
  ovCtx.strokeStyle="lime";
  ovCtx.strokeRect(roi.x,roi.y,roi.w,roi.h);
};
ov.onmouseup = ()=>selecting=false;

/* ===== Main Loop ===== */
function loop(){
  capCtx.drawImage(video,0,0);
  if(roi && roi.w>10 && roi.h>10){
    const img=capCtx.getImageData(roi.x,roi.y,roi.w,roi.h);
    resultDiv.textContent = readNumber(img) ?? "---";
  }
  requestAnimationFrame(loop);
}

/* ===== OCR ===== */

function readNumber(img){
  const gray = toGray(img);
  const edge = sobel(gray,img.width,img.height);
  const bin = otsu(edge);
  const comps = connectedComponents(bin,img.width,img.height);
  if(!comps.length) return null;

  comps.sort((a,b)=>a.x-b.x);
  return comps.map(c=>classifyDigit(c.data)).join("");
}

/* --- grayscale --- */
function toGray(img){
  const g=new Uint8Array(img.width*img.height);
  for(let i=0,j=0;i<img.data.length;i+=4,j++)
    g[j]=img.data[i]*0.3+img.data[i+1]*0.59+img.data[i+2]*0.11;
  return g;
}

/* --- sobel --- */
function sobel(g,w,h){
  const out=new Uint8Array(g.length);
  for(let y=1;y<h-1;y++)
    for(let x=1;x<w-1;x++){
      const i=y*w+x;
      const gx=-g[i-w-1]-2*g[i-1]-g[i+w-1]+g[i-w+1]+2*g[i+1]+g[i+w+1];
      const gy=-g[i-w-1]-2*g[i-w]-g[i-w+1]+g[i+w-1]+2*g[i+w]+g[i+w+1];
      out[i]=Math.min(255,Math.hypot(gx,gy));
    }
  return out;
}

/* --- Otsu --- */
function otsu(g){
  const hist=new Uint32Array(256);
  for(const v of g) hist[v]++;
  let sum=0; for(let i=0;i<256;i++) sum+=i*hist[i];
  let wB=0,sumB=0,max=0,th=0;
  const total=g.length;
  for(let i=0;i<256;i++){
    wB+=hist[i]; if(!wB) continue;
    const wF=total-wB; if(!wF) break;
    sumB+=i*hist[i];
    const mB=sumB/wB,mF=(sum-sumB)/wF;
    const v=wB*wF*(mB-mF)**2;
    if(v>max){max=v;th=i;}
  }
  return g.map(v=>v>th?1:0);
}

/* --- Connected Components --- */
function connectedComponents(bin,w,h){
  const vis=new Uint8Array(bin.length);
  const res=[];
  const dirs=[1,-1,w,-w];
  for(let i=0;i<bin.length;i++){
    if(!bin[i]||vis[i]) continue;
    let minx=w,maxx=0,miny=h,maxy=0;
    const stack=[i], pts=[];
    vis[i]=1;
    while(stack.length){
      const p=stack.pop(),x=p%w,y=p/w|0;
      pts.push(p);
      minx=Math.min(minx,x); maxx=Math.max(maxx,x);
      miny=Math.min(miny,y); maxy=Math.max(maxy,y);
      for(const d of dirs){
        const n=p+d;
        if(bin[n]&&!vis[n]){
          vis[n]=1; stack.push(n);
        }
      }
    }
    const dw=maxx-minx+1, dh=maxy-miny+1;
    if(dw>5 && dh>10){
      const img=new Uint8Array(dw*dh);
      pts.forEach(p=>{
        const x=p%w-minx,y=(p/w|0)-miny;
        img[y*dw+x]=1;
      });
      res.push({x:minx,data:resize(img,dw,dh)});
    }
  }
  return res;
}

/* --- Resize to 28x28 --- */
function resize(bin,w,h){
  const out=new Uint8Array(28*28);
  for(let y=0;y<28;y++)
    for(let x=0;x<28;x++){
      const sx=x*w/28|0, sy=y*h/28|0;
      out[y*28+x]=bin[sy*w+sx];
    }
  return out;
}

/* --- Simple template classifier --- */
const DIGITS = loadTemplates();

function classifyDigit(img){
  let best="?", err=1e9;
  for(const d in DIGITS){
    const t=DIGITS[d];
    let e=0;
    for(let i=0;i<img.length;i++) e+=img[i]^t[i];
    if(e<err){err=e;best=d;}
  }
  return best;
}

/* --- Pre-generated templates (drawn once) --- */
function loadTemplates(){
  const map={};
  const c=document.createElement("canvas");
  c.width=c.height=28;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#000"; ctx.font="24px monospace";
  for(let d=0;d<=9;d++){
    ctx.clearRect(0,0,28,28);
    ctx.fillText(d,4,24);
    const id=ctx.getImageData(0,0,28,28).data;
    const bin=new Uint8Array(28*28);
    for(let i=0;i<id.length;i+=4)
      bin[i/4]=(id[i]<128)?1:0;
    map[d]=bin;
  }
  return map;
}
</script>
</body>
</html>
