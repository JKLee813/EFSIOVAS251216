# EFSIOVAS251216
개조테스트

## 2️⃣ 템플릿 없이 UI를 찾는 핵심: Sobel Edge
function Sobel(frame, frame_width, rect)

역할

화면 전체에서 경계선(윤곽) 검출

숫자 UI, 타이머 UI는 사각형 테두리를 가짐

그 특성을 이용

흐름

Sobel 필터로 밝기 변화 큰 부분 추출

일정 길이 이상인 수평선 / 수직선만 유지

선들의 교차점으로 사각형 후보 생성

👉 “여기가 UI 박스다” 를 자동으로 찾음
👉 해상도, 위치 바뀌어도 동작

📌 이게 이 코드의 가장 똑똑한 부분입니다.


## 3️⃣ 시간 인식 방식 (7세그먼트 분석)
function Time(frame, frame_width, rect)

방식

타이머 숫자를 7세그먼트 디스플레이처럼 해석

각 숫자를 5×3 점으로 샘플링

켜진 세그먼트 비트마스크 생성

switch(segment_display){
  case 0x77: segment_value[i] = 0;
  case 0x24: segment_value[i] = 1;
  ...
}


📌 즉:

OCR 라이브러리 ❌

“숫자 구조 자체를 코드로 정의”

그래서 빠르고 정확합니다.


##4️⃣ HP 인식 방식 (이게 진짜 핵심)
function Hp(frame, frame_width, rect)

🔥 템플릿 매칭이 아닌 이유

HP 숫자는 이렇게 처리됩니다:

Sharpen 필터로 숫자 윤곽 강조

세로 한 줄씩 스캔

픽셀 존재 → 비트 시프트로 저장

sum <<= y - last_y;
sum |= 1;


결과는 이런 비트 배열이 됨:

[62, 65, 65, 65, 62] // 숫자 0


미리 정의된 비트 패턴 테이블과 XOR 비교

오차 최소인 숫자를 선택

let error = bit_count(bin[i] ^ arr[j]);


👉 형태 인식 기반 OCR
👉 폰트·색 조금 달라도 인식 가능


## 5️⃣ 페이즈 / 패턴 감지 방식 (빨간색 영역)
if(r == 255 && g + b == 0)

이건 숫자가 아니라 상태 감지

색을 5단계로 단순화

완전한 빨강 영역만 flood-fill

영역 크기 비율 계산

ratio = count / (frame_width * frame_height)


일정 비율 이상이면

패턴 존재

페이즈 진입 판단

👉 보스 패턴 트리거 감지용


## 6️⃣ 왜 이 방식이 좋은가?
방식	템플릿 매칭	이 코드
해상도 변화	취약	강함
UI 위치 변경	취약	자동 탐색
성능	무거움	빠름
유지보수	템플릿 교체	코드만 유지
정확도	중간	매우 높음

📌 “게임 자동화 고수들이 쓰는 방식” 입니다.

## 🔥 한 줄 요약

이 코드는
이미지를 비교하는 게 아니라
화면을 수학적으로 해석해서 숫자와 상태를 읽습니다.

UI는 에지 구조로 탐색

숫자는 비트 패턴 OCR

상태는 색 영역 분석

전부 순수 JS + Canvas
